/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright(c) 2017-2018 Nippon Telegraph and Telephone Corporation
 */

#ifndef __SPP_VF_H__
#define __SPP_VF_H__

/**
 * @file
 * SPP_VF main
 *
 * Main function of spp_vf.
 * This provides the function for initializing and starting the threads.
 */

#include "common.h"

/** The max number of client ID */
#define SPP_CLIENT_MAX    128

/** command setting type */
enum spp_command_action {
	SPP_CMD_ACTION_NONE,  /**< none */
	SPP_CMD_ACTION_START, /**< start */
	SPP_CMD_ACTION_STOP,  /**< stop */
	SPP_CMD_ACTION_ADD,   /**< add */
	SPP_CMD_ACTION_DEL,   /**< delete */
};

/**
 * Get client ID
 *
 * @return Client ID(0~127)
 */
int spp_get_client_id(void);

/**
 * Update Classifier_table
 *
 * @param action
 *  Action identifier (add or del)
 * @param type
 *  Classify type (currently only for mac)
 * @param data
 *  Value to be classified
 * @param port
 *  Destination port type and number
 *
 * @retval SPP_RET_OK succeeded.
 * @retval SPP_RET_NG failed.
 */
int spp_update_classifier_table(
		enum spp_command_action action,
		enum spp_classifier_type type,
		int vid,
		const char *mac,
		const struct spp_port_index *port);

/**
 * Update component
 *
 * @param action
 *  Action identifier (start or stop)
 * @param name
 *  Component name
 * @param lcore_id
 *  Logical core number
 * @param type
 *  Component type
 *
 * @retval SPP_RET_OK succeeded.
 * @retval SPP_RET_NG failed.
 */
int spp_update_component(
		enum spp_command_action action,
		const char *name, unsigned int lcore_id,
		enum spp_component_type type);

/**
 * Update port
 *
 * @param action
 *  Action identifier (add or del)
 * @param port
 *  Port type and number
 * @param rxtx
 *  rx/tx identifier
 * @param name
 *  Attached component name
 *
 * @retval SPP_RET_OK succeeded.
 * @retval SPP_RET_NG failed.
 */
int spp_update_port(
		enum spp_command_action action,
		const struct spp_port_index *port,
		enum spp_port_rxtx rxtx,
		const char *name,
		const struct spp_port_ability *ability);

/**
 * Flush SPP component
 *
 * @retval SPP_RET_OK succeeded.
 * @retval SPP_RET_NG failed.
 */
int spp_flush(void);

/**
 * Iterate core information
 *
 * @param params
 *  The pointer to struct spp_iterate_core_params.@n
 *  The value for generating core information (status command).
 *
 * @retval SPP_RET_OK succeeded.
 * @retval SPP_RET_NG failed.
 */
int spp_iterate_core_info(struct spp_iterate_core_params *params);

/**
 * Iterate Classifier_table
 *
 * @param params
 *  The pointer to struct spp_iterate_classifier_table_params.@n
 *  The value for generating classifier table.
 *
 * @retval SPP_RET_OK succeeded.
 * @retval SPP_RET_NG failed.
 */
int spp_iterate_classifier_table(
		struct spp_iterate_classifier_table_params *params);

/**
 * Get component type being updated on target core
 *
 * @param lcore_id
 *  Logical core ID.
 *
 * @return
 *  Type of component that will be executed on
 *  specified logical core after update.
 */
enum spp_component_type spp_get_component_type_update(unsigned int lcore_id);

/**
 * Check mac address used on the port for registering or removing
 *
 * @param vid
 *  VLAN ID to be validated.
 * @param mac_addr
 *  Mac address to be validated.
 * @param iface_type
 *  Interface to be validated.
 * @param iface_no
 *  Interface number to be validated.
 *
 * @return
 *  True if target identifier(VLAN ID, MAC address)
 *  matches identifier(VLAN ID, MAC address) of port.
 */
int spp_check_classid_used_port(
		int vid, uint64_t mac_addr,
		enum port_type iface_type, int iface_no);

/**
 * Check if port has been added.
 *
 * @param iface_type
 *  Interface to be validated.
 * @param iface_no
 *  Interface number to be validated.
 *
 * @return
 *  True if port has been added.
 */
int spp_check_added_port(enum port_type iface_type, int iface_no);

/**
 * Check if port has been flushed.
 *
 * @param iface_type
 *  Interface to be validated.
 * @param iface_no
 *  Interface number to be validated.
 *
 * @return
 *  True if port has been flushed.
 */
int spp_check_flush_port(enum port_type iface_type, int iface_no);

/**
 * Get the port number of DPDK.
 *
 * @param iface_type
 *  Interface type obtained from port.
 * @param iface_no
 *  Interface number obtained from port.
 *
 * @return
 *  Port id generated by DPDK.
 */
int spp_get_dpdk_port(enum port_type iface_type, int iface_no);

/**
 * Extract if-type/if-number from port string
 *
 * @param port
 *  Character string expressing the port, e.g. "phy:0","ring:1"
 * @param iface_type
 *  Interface type obtained from port.
 * @param iface_no
 *  Interface number obtained from port.
 *
 * @retval 0  succeeded.
 * @retval -1 failed.
 */
int spp_get_iface_index(
		const char *port,
		enum port_type *iface_type,
		int *iface_no);

/**
 * Change component type from string to type value.
 *
 * @param type_str
 *  Name string for each component
 *
 * @return
 *  Component type corresponding to type_str.
 */
enum spp_component_type spp_change_component_type(const char *type_str);

#endif /* __SPP_VF_H__ */
