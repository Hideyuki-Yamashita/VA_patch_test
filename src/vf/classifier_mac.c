/*
 *   BSD LICENSE
 *
 *   Copyright(c) 2017 Nippon Telegraph and Telephone Corporation
 *   All rights reserved.
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *     * Neither the name of Nippon Telegraph and Telephone Corporation
 *       nor the names of its contributors may be used to endorse or
 *       promote products derived from this software without specific
 *       prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <math.h>

#include <rte_common.h>
#include <rte_mbuf.h>
#include <rte_log.h>
#include <rte_cycles.h>
#include <rte_malloc.h>
#include <rte_memcpy.h>
#include <rte_random.h>
#include <rte_byteorder.h>
#include <rte_per_lcore.h>
#include <rte_eal.h>
#include <rte_launch.h>
#include <rte_hash.h>

#include "spp_vf.h"
#include "spp_port.h"
#include "classifier_mac.h"

#define RTE_LOGTYPE_SPP_CLASSIFIER_MAC RTE_LOGTYPE_USER1

#ifdef RTE_MACHINE_CPUFLAG_SSE4_2
#include <rte_hash_crc.h>
#define DEFAULT_HASH_FUNC rte_hash_crc
#else
#include <rte_jhash.h>
#define DEFAULT_HASH_FUNC rte_jhash
#endif

/* number of classifier mac table entry */
#define NUM_CLASSIFIER_MAC_TABLE_ENTRY 128

/* number of classifier information (reference/update) */
#define NUM_CLASSIFIER_MAC_INFO 2

/* interval that wait until change update index (micro second) */
#define CHANGE_UPDATE_INDEX_WAIT_INTERVAL SPP_CHANGE_UPDATE_INTERVAL

/* interval that transmit burst packet, if buffer is not filled (nano second) */
#define DRAIN_TX_PACKET_INTERVAL 100

/*
 * hash table name buffer size
 *[reson for value]
 *	in dpdk's lib/librte_hash/rte_cuckoo_hash.c
 *		snprintf(ring_name, sizeof(ring_name), "HT_%s", params->name);
 *		snprintf(hash_name, sizeof(hash_name), "HT_%s", params->name);
 *	ring_name buffer size is RTE_RING_NAMESIZE
 *	hash_name buffer size is RTE_HASH_NAMESIZE
 */
static const size_t HASH_TABLE_NAME_BUF_SZ =
		((RTE_HASH_NAMESIZE < RTE_RING_NAMESIZE) ?  RTE_HASH_NAMESIZE :
		RTE_RING_NAMESIZE) - 3;

/* mac address string(xx:xx:xx:xx:xx:xx) buffer size */
static const size_t ETHER_ADDR_STR_BUF_SZ =
		ETHER_ADDR_LEN * 2 + (ETHER_ADDR_LEN - 1) + 1;

/* classified data (destination port, target packets, etc) */
struct classified_data {
	/* interface type (see "enum port_type") */
	enum port_type  iface_type;

	/* index of ports handled by classifier */
	int             iface_no;

	/* id for interface generated by spp_vf */
	int             iface_no_global;

	/* port id generated by DPDK */
	uint16_t        port;

	/* the number of packets in pkts[] */
	uint16_t        num_pkt;

	/* packet array to be classified */
	struct rte_mbuf *pkts[MAX_PKT_BURST];
};

/* classifier component information */
struct component_info {
	/* component name */
	char name[SPP_NAME_STR_LEN];

	/* hash table keeps classifier_table */
	struct rte_hash *classifier_table;

	/* number of valid classification */
	int num_active_classified;

	/* index of valid classification */
	int active_classifieds[RTE_MAX_ETHPORTS];

	/* index of default classification */
	int default_classified;

	/* number of transmission ports */
	int n_classified_data_tx;

	/* receive port handled by classifier */
	struct classified_data classified_data_rx;

	/* transmission ports handled by classifier */
	struct classified_data classified_data_tx[RTE_MAX_ETHPORTS];
};

/* classifier management information */
struct management_info {
	/* classifier information */
	struct component_info cmp_infos[NUM_CLASSIFIER_MAC_INFO];

	/* Reference index number for classifier information */
	volatile int ref_index;

	/* Update index number for classifier information */
	volatile int upd_index;
};

/* classifier information per lcore */
static struct management_info g_mng_infos[RTE_MAX_LCORE];

/**
 * Hash table count used for making a name of hash table
 *
 * This function is required because it is incremented at the time of use,
 * but since we want to start at 0.
 */
static rte_atomic16_t g_hash_table_count = RTE_ATOMIC16_INIT(0xff);

static inline int
is_used_mng_info(const struct management_info *mng_info)
{
	return (mng_info != NULL &&
			mng_info->cmp_infos[0].classifier_table != NULL);
}

/* initialize classifier information. */
static int
init_component_info(struct component_info *cmp_info,
		const struct spp_component_info *component_info)
{
	int ret = -1;
	int i;
	struct rte_hash **classifier_table = &cmp_info->classifier_table;
	struct ether_addr eth_addr;
	char mac_addr_str[ETHER_ADDR_STR_BUF_SZ];
	struct classified_data *clsd_data_rx =
			&cmp_info->classified_data_rx;
	struct classified_data *clsd_data_tx =
			cmp_info->classified_data_tx;
	struct spp_port_info *tx_port = NULL;

	rte_hash_reset(*classifier_table);
	cmp_info->num_active_classified = 0;
	cmp_info->default_classified = -1;
	cmp_info->n_classified_data_tx = component_info->num_tx_port;
	if (component_info->num_rx_port == 0) {
		clsd_data_rx->iface_type      = UNDEF;
		clsd_data_rx->iface_no        = 0;
		clsd_data_rx->iface_no_global = 0;
		clsd_data_rx->port            = 0;
		clsd_data_rx->num_pkt         = 0;
	} else {
		clsd_data_rx->iface_type      =
				component_info->rx_ports[0]->iface_type;
		clsd_data_rx->iface_no        = 0;
		clsd_data_rx->iface_no_global =
				component_info->rx_ports[0]->iface_no;
		clsd_data_rx->port            =
				component_info->rx_ports[0]->dpdk_port;
		clsd_data_rx->num_pkt         = 0;
	}

	for (i = 0; i < component_info->num_tx_port; i++) {
		tx_port = component_info->tx_ports[i];

		/* store ports information */
		clsd_data_tx[i].iface_type      = tx_port->iface_type;
		clsd_data_tx[i].iface_no        = i;
		clsd_data_tx[i].iface_no_global = tx_port->iface_no;
		clsd_data_tx[i].port            = tx_port->dpdk_port;
		clsd_data_tx[i].num_pkt         = 0;

		if (component_info->tx_ports[i]->mac_addr == 0)
			continue;

		/* store active tx_port that associate with mac address */
		cmp_info->active_classifieds[cmp_info->
				num_active_classified++] = i;

		/* store default classified */
		if (unlikely(tx_port->mac_addr ==
				SPP_DEFAULT_CLASSIFIED_DMY_ADDR)) {
			cmp_info->default_classified = i;
			RTE_LOG(INFO, SPP_CLASSIFIER_MAC, "default classified. "
					"iface_type=%d, iface_no=%d, dpdk_port=%d\n",
					tx_port->iface_type,
					tx_port->iface_no,
					tx_port->dpdk_port);
			continue;
		}

		/* add entry to classifier mac table */
		rte_memcpy(&eth_addr, &tx_port->mac_addr, ETHER_ADDR_LEN);
		ether_format_addr(mac_addr_str, sizeof(mac_addr_str),
				&eth_addr);

		ret = rte_hash_add_key_data(*classifier_table,
				(void *)&eth_addr, (void *)(long)i);
		if (unlikely(ret < 0)) {
			RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
					"Cannot add entry to classifier mac table. "
					"ret=%d, mac_addr=%s\n",
					ret, mac_addr_str);
			rte_hash_free(*classifier_table);
			*classifier_table = NULL;
			return -1;
		}

		RTE_LOG(INFO, SPP_CLASSIFIER_MAC, "Add entry to classifier mac table. "
				"mac_addr=%s, iface_type=%d, iface_no=%d, dpdk_port=%d\n",
				mac_addr_str,
				tx_port->iface_type,
				tx_port->iface_no,
				tx_port->dpdk_port);
	}

	return 0;
}

/* initialize classifier. */
static int
init_classifier(struct management_info *mng_info)
{
	int ret = -1;
	int i;
	char hash_table_name[HASH_TABLE_NAME_BUF_SZ];

	struct rte_hash **classifier_mac_table = NULL;
	struct spp_component_info component_info;

	memset(mng_info, 0, sizeof(struct management_info));
	/*
	 * Set the same value for "ref_index" and "upd_index"
	 * so that it will not be changed from others during initialization,
	 * and update "upd_index" after initialization is completed.
	 * Therefore, this setting is consciously described.
	 */
	mng_info->ref_index = 0;
	mng_info->upd_index = 0;
	memset(&component_info, 0x00, sizeof(component_info));

#ifdef RTE_MACHINE_CPUFLAG_SSE4_2
	RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC, "Enabled SSE4.2. use CRC hash.\n");
#else
	RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC, "Disabled SSE4.2. use Jenkins hash.\n");
#endif

	for (i = 0; i < NUM_CLASSIFIER_MAC_INFO; ++i) {

		classifier_mac_table =
				&mng_info->cmp_infos[i].classifier_table;

		/* make hash table name(require uniqueness between processes) */
		sprintf(hash_table_name, "cmtab_%07x%02hx%x",
				getpid(),
				rte_atomic16_add_return(&g_hash_table_count, 1),
				i);

		RTE_LOG(INFO, SPP_CLASSIFIER_MAC, "Create table. name=%s, bufsz=%lu\n",
				hash_table_name, HASH_TABLE_NAME_BUF_SZ);

		/* set hash creating parameters */
		struct rte_hash_parameters hash_params = {
				.name      = hash_table_name,
				.entries   = NUM_CLASSIFIER_MAC_TABLE_ENTRY,
				.key_len   = sizeof(struct ether_addr),
				.hash_func = DEFAULT_HASH_FUNC,
				.hash_func_init_val = 0,
				.socket_id = rte_socket_id(),
		};

		/* create classifier mac table (hash table) */
		*classifier_mac_table = rte_hash_create(&hash_params);
		if (unlikely(*classifier_mac_table == NULL)) {
			RTE_LOG(ERR, SPP_CLASSIFIER_MAC, "Cannot create classifier mac table. "
					"name=%s\n", hash_table_name);
			return -1;
		}
	}

	/* populate the classifier information at reference */
	ret = init_component_info(&mng_info->
			cmp_infos[mng_info->ref_index], &component_info);
	if (unlikely(ret != 0)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
				"Cannot initialize classifier mac table. ret=%d\n",
				ret);
		return -1;
	}

	/* updating side can be set by completion of initialization. */
	mng_info->upd_index = mng_info->ref_index + 1;

	return 0;
}

/* uninitialize classifier. */
static void
uninit_classifier(struct management_info *mng_info)
{
	int i;

	for (i = 0; i < NUM_CLASSIFIER_MAC_INFO; ++i) {
		if (mng_info->cmp_infos[i].classifier_table != NULL) {
			rte_hash_free(mng_info->cmp_infos[i].
					classifier_table);
			mng_info->cmp_infos[i].classifier_table = NULL;
			mng_info->ref_index = 0;
			mng_info->upd_index = 0;
		}
	}
}

/* transmit packet to one destination. */
static inline void
transmit_packet(struct classified_data *clsd_data)
{
	int i;
	uint16_t n_tx;

	/* transmit packets */
	n_tx = spp_eth_tx_burst(clsd_data->port, 0,
			clsd_data->pkts, clsd_data->num_pkt);

	/* free cannot transmit packets */
	if (unlikely(n_tx != clsd_data->num_pkt)) {
		for (i = n_tx; i < clsd_data->num_pkt; i++)
			rte_pktmbuf_free(clsd_data->pkts[i]);
		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
				"drop packets(tx). num=%hu, dpdk_port=%hu\n",
				(uint16_t)(clsd_data->num_pkt - n_tx),
				clsd_data->port);
	}

	clsd_data->num_pkt = 0;
}

/* transmit packet to one destination. */
static inline void
transmit_all_packet(struct component_info *cmp_info)
{
	int i;
	struct classified_data *clsd_data_tx = cmp_info->classified_data_tx;

	for (i = 0; i < cmp_info->n_classified_data_tx; i++) {
		if (unlikely(clsd_data_tx[i].num_pkt != 0)) {
			RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
					"transmit all packets (drain). "
					"index=%d, "
					"num_pkt=%hu\n",
					i,
					clsd_data_tx[i].num_pkt);
			transmit_packet(&clsd_data_tx[i]);
		}
	}
}

/* set mbuf pointer to tx buffer and transmit packet, if buffer is filled */
static inline void
push_packet(struct rte_mbuf *pkt, struct classified_data *clsd_data)
{
	clsd_data->pkts[clsd_data->num_pkt++] = pkt;

	/* transmit packet, if buffer is filled */
	if (unlikely(clsd_data->num_pkt == MAX_PKT_BURST)) {
		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
				"transmit packets (buffer is filled). "
				"iface_type=%d, iface_no={%d,%d}, tx_port=%hu, num_pkt=%hu\n",
				clsd_data->iface_type,
				clsd_data->iface_no_global,
				clsd_data->iface_no,
				clsd_data->port,
				clsd_data->num_pkt);
		transmit_packet(clsd_data);
	}
}

/* handle L2 multicast(include broadcast) packet */
static inline void
handle_l2multicast_packet(struct rte_mbuf *pkt,
		struct component_info *cmp_info,
		struct classified_data *clsd_data)
{
	int i;

	if (unlikely(cmp_info->num_active_classified == 0)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC, "No mac address.(l2 multicast packet)\n");
		rte_pktmbuf_free(pkt);
		return;
	}

	rte_mbuf_refcnt_update(pkt,
			(cmp_info->num_active_classified - 1));

	for (i = 0; i < cmp_info->num_active_classified; i++) {
		push_packet(pkt, clsd_data +
				(long)cmp_info->active_classifieds[i]);
	}
}

/*
 * classify packet by destination mac address,
 * and transmit packet (conditional).
 */
static inline void
classify_packet(struct rte_mbuf **rx_pkts, uint16_t n_rx,
		struct component_info *cmp_info,
		struct classified_data *clsd_data)
{
	int ret;
	int i;
	struct ether_hdr *eth;
	void *lookup_data;
	char mac_addr_str[ETHER_ADDR_STR_BUF_SZ];

	for (i = 0; i < n_rx; i++) {
		eth = rte_pktmbuf_mtod(rx_pkts[i], struct ether_hdr *);

		/* find in table (by destination mac address)*/
		ret = rte_hash_lookup_data(cmp_info->classifier_table,
				(const void *)&eth->d_addr, &lookup_data);
		if (ret < 0) {
			/* L2 multicast(include broadcast) ? */
			if (unlikely(is_multicast_ether_addr(&eth->d_addr))) {
				RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
						"multicast mac address.\n");
				handle_l2multicast_packet(rx_pkts[i],
						cmp_info,
						clsd_data);
				continue;
			}

			/* if no default, drop packet */
			if (unlikely(cmp_info->default_classified ==
					-1)) {
				ether_format_addr(mac_addr_str,
						sizeof(mac_addr_str),
						&eth->d_addr);
				RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
						"unknown mac address. "
						"ret=%d, mac_addr=%s\n",
						ret, mac_addr_str);
				rte_pktmbuf_free(rx_pkts[i]);
				continue;
			}

			/* to default classified */
			RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
					"to default classified.\n");
			lookup_data = (void *)(long)cmp_info->
					default_classified;
		}

		/*
		 * set mbuf pointer to tx buffer
		 * and transmit packet, if buffer is filled
		 */
		push_packet(rx_pkts[i], clsd_data + (long)lookup_data);
	}
}

/* change update index at classifier management information */
static inline void
change_update_index(struct management_info *mng_info, int id)
{
	if (unlikely(mng_info->ref_index ==
			mng_info->upd_index)) {
		/* Change reference index of port ability. */
		spp_port_ability_change_index(PORT_ABILITY_CHG_INDEX_REF, 0, 0);

		/* Transmit all packets for switching the using data. */
		transmit_all_packet(mng_info->cmp_infos +
				mng_info->ref_index);

		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
				"Core[%u] Change update index.\n", id);
		mng_info->ref_index =
				(mng_info->upd_index + 1) %
				NUM_CLASSIFIER_MAC_INFO;
	}
}

/* classifier(mac address) initialize globals. */
int
spp_classifier_mac_init(void)
{
	memset(g_mng_infos, 0, sizeof(g_mng_infos));

	return 0;
}

/* classifier(mac address) update component info. */
int
spp_classifier_mac_update(struct spp_component_info *component_info)
{
	int ret = -1;
	int id = component_info->component_id;
	struct management_info *mng_info = g_mng_infos + id;
	struct component_info *cmp_info = NULL;

	RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
			"Component[%u] Start update component.\n", id);

	/* wait until no longer access the new update side */
	while (likely(mng_info->ref_index ==
			mng_info->upd_index))
		rte_delay_us_block(CHANGE_UPDATE_INDEX_WAIT_INTERVAL);

	cmp_info = mng_info->cmp_infos + mng_info->upd_index;

	/* initialize update side classifier information */
	ret = init_component_info(cmp_info, component_info);
	if (unlikely(ret != 0)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
				"Cannot update classifier mac. ret=%d\n", ret);
		return ret;
	}
	memcpy(cmp_info->name, component_info->name, SPP_NAME_STR_LEN);

	/* change index of reference side */
	mng_info->upd_index = mng_info->ref_index;

	/* wait until no longer access the new update side */
	while (likely(mng_info->ref_index ==
			mng_info->upd_index))
		rte_delay_us_block(CHANGE_UPDATE_INDEX_WAIT_INTERVAL);

	RTE_LOG(INFO, SPP_CLASSIFIER_MAC,
			"Component[%u] Complete update component.\n", id);

	return 0;
}

/* classifier(mac address) thread function. */
int
spp_classifier_mac_do(int id)
{
	int ret = -1;
	int i;
	int n_rx;
	unsigned int lcore_id = rte_lcore_id();
	struct management_info *mng_info = g_mng_infos + id;
	struct component_info *cmp_info = NULL;
	struct rte_mbuf *rx_pkts[MAX_PKT_BURST];

	struct classified_data *clsd_data_rx = NULL;
	struct classified_data *clsd_data_tx = NULL;

	uint64_t cur_tsc, prev_tsc = 0;
	const uint64_t drain_tsc = (rte_get_tsc_hz() + US_PER_S - 1) /
			US_PER_S * DRAIN_TX_PACKET_INTERVAL;

	/* initialize */
	ret = init_classifier(mng_info);
	if (unlikely(ret != 0))
		return ret;

	while (likely(spp_get_core_status(lcore_id) == SPP_CORE_FORWARD) &&
			likely(spp_check_core_index(lcore_id) == 0)) {
		/* change index of update side */
		change_update_index(mng_info, id);

		/* decide classifier information of the current cycle */
		cmp_info = mng_info->cmp_infos + mng_info->ref_index;
		clsd_data_rx = &cmp_info->classified_data_rx;
		clsd_data_tx = cmp_info->classified_data_tx;

		/* drain tx packets, if buffer is not filled for interval */
		cur_tsc = rte_rdtsc();
		if (unlikely(cur_tsc - prev_tsc > drain_tsc)) {
			for (i = 0; i < cmp_info->n_classified_data_tx;
					i++) {
				if (likely(clsd_data_tx[i].num_pkt == 0))
					continue;

				RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
						"transmit packets (drain). "
						"index=%d, "
						"num_pkt=%hu, "
						"interval=%lu\n",
						i,
						clsd_data_tx[i].num_pkt,
						cur_tsc - prev_tsc);
				transmit_packet(&clsd_data_tx[i]);
			}
			prev_tsc = cur_tsc;
		}

		if (clsd_data_rx->iface_type == UNDEF)
			continue;

		/* retrieve packets */
		n_rx = spp_eth_rx_burst(clsd_data_rx->port, 0,
				rx_pkts, MAX_PKT_BURST);
		if (unlikely(n_rx == 0))
			continue;

		/* classify and transmit (filled) */
		classify_packet(rx_pkts, n_rx, cmp_info, clsd_data_tx);
	}

	/* just in case */
	change_update_index(mng_info, id);

	/* uninitialize */
	uninit_classifier(mng_info);

	return 0;
}

/* classifier iterate component information */
int
spp_classifier_get_component_status(
		unsigned int lcore_id, int id,
		struct spp_iterate_core_params *params)
{
	int ret = -1;
	int i, num_tx, num_rx = 0;
	struct management_info *mng_info;
	struct component_info *cmp_info;
	struct classified_data *clsd_data;
	struct spp_port_index rx_ports[RTE_MAX_ETHPORTS];
	struct spp_port_index tx_ports[RTE_MAX_ETHPORTS];

	mng_info = g_mng_infos + id;
	if (!is_used_mng_info(mng_info)) {
		RTE_LOG(ERR, SPP_CLASSIFIER_MAC,
				"Component[%d] Not used. (status)(core = %d, type = %d)\n",
				id, lcore_id, SPP_COMPONENT_CLASSIFIER_MAC);
		return -1;
	}

	cmp_info = mng_info->cmp_infos + mng_info->ref_index;
	clsd_data = cmp_info->classified_data_tx;

	memset(rx_ports, 0x00, sizeof(rx_ports));
	if (cmp_info->classified_data_rx.iface_type != UNDEF) {
		num_rx = 1;
		rx_ports[0].iface_type = cmp_info->
				classified_data_rx.iface_type;
		rx_ports[0].iface_no   = cmp_info->
				classified_data_rx.iface_no_global;
	}

	memset(tx_ports, 0x00, sizeof(tx_ports));
	num_tx = cmp_info->n_classified_data_tx;
	for (i = 0; i < num_tx; i++) {
		tx_ports[i].iface_type = clsd_data[i].iface_type;
		tx_ports[i].iface_no   = clsd_data[i].iface_no_global;
	}

	/* Set the information with the function specified by the command. */
	ret = (*params->element_proc)(
		params, lcore_id,
		cmp_info->name, SPP_TYPE_CLASSIFIER_MAC_STR,
		num_rx, rx_ports, num_tx, tx_ports);
	if (unlikely(ret != 0))
		return -1;

	return 0;
}

/* classifier(mac address) iterate classifier table. */
int
spp_classifier_mac_iterate_table(
		struct spp_iterate_classifier_table_params *params)
{
	int ret, i;
	const void *key;
	void *data;
	uint32_t next = 0;
	struct management_info *mng_info;
	struct component_info *cmp_info;
	struct classified_data *clsd_data;
	struct spp_port_index port;
	char mac_addr_str[ETHER_ADDR_STR_BUF_SZ];

	for (i = 0; i < RTE_MAX_LCORE; i++) {
		mng_info = g_mng_infos + i;
		if (!is_used_mng_info(mng_info))
			continue;

		cmp_info = mng_info->cmp_infos + mng_info->ref_index;

		clsd_data = cmp_info->classified_data_tx;

		RTE_LOG(DEBUG, SPP_CLASSIFIER_MAC,
			"Core[%u] Start iterate classifier table.\n", i);

		if (cmp_info->default_classified >= 0) {
			port.iface_type = (clsd_data +
					cmp_info->default_classified)->
					iface_type;
			port.iface_no   = (clsd_data +
					cmp_info->default_classified)->
					iface_no_global;

			(*params->element_proc)(
					params,
					SPP_CLASSIFIER_TYPE_MAC,
					SPP_DEFAULT_CLASSIFIED_SPEC_STR,
					&port);
		}

		next = 0;
		while (1) {
			ret = rte_hash_iterate(
					cmp_info->classifier_table,
					&key, &data, &next);

			if (unlikely(ret < 0))
				break;

			ether_format_addr(mac_addr_str, sizeof(mac_addr_str),
					(const struct ether_addr *)key);

			port.iface_type = (clsd_data + (long)data)->
					iface_type;
			port.iface_no   = (clsd_data + (long)data)->
					iface_no_global;

			(*params->element_proc)(
					params,
					SPP_CLASSIFIER_TYPE_MAC,
					mac_addr_str,
					&port);
		}
	}

	return 0;
}
