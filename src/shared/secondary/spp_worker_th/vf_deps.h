/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright(c) 2019 Nippon Telegraph and Telephone Corporation
 */

#ifndef _SPPWK_TH_VF_DEPS_H_
#define _SPPWK_TH_VF_DEPS_H_

#include <rte_malloc.h>
#include <rte_hash.h>
#include "cmd_utils.h"

/** Number of VLAN ID */
#define NOF_VLAN 4096

/* Classifier for MAC addresses. */
struct mac_classifier {
	struct rte_hash *cls_tbl;  /* Hash table for MAC classification. */
	int nof_cls_ports;  /* Num of ports classified validly. */
	int cls_ports[RTE_MAX_ETHPORTS];  /* Ports for classification. */
	int default_cls_idx;  /* Default index for classification. */
};

/* classified data (destination port, target packets, etc) */
/* TODO(yasufum) rename `classified_data`. */
/* TODO(yasufum) confirm what `iface_no_global` does mean? */
struct classified_data {
	enum port_type iface_type;
	int iface_no;   /* Index of ports handled by classifier. */
	int iface_no_global;  /* ID for interface generated by spp_vf */
	uint16_t port;  /* Ethdev port ID. */
	uint16_t nof_pkts;  /* Number of packets in pkts[]. */
	struct rte_mbuf *pkts[MAX_PKT_BURST];  /* packets to be classified. */
};

/* classifier component information */
struct component_info {
	char name[STR_LEN_NAME];  /* component name */
	int mac_addr_entry;  /* mac address entry flag */

	/* mac address classification per vlan-id */
	struct mac_classifier *mac_classifications[NOF_VLAN];

	int n_classified_data_tx;  /* number of transmission ports */
	struct classified_data classified_data_rx;  /* RX handled by cls */
	/* transmission ports handled by classifier */
	struct classified_data classified_data_tx[RTE_MAX_ETHPORTS];
};

/* free mac classification instance. */
static inline void
free_mac_classification(struct mac_classifier *mac_cls)
{
	if (mac_cls == NULL)
		return;

	if (mac_cls->cls_tbl != NULL)
		rte_hash_free(mac_cls->cls_tbl);

	rte_free(mac_cls);
}

/**
 * classifier(mac address) update component info.
 *
 * @param comp_info Pointer to internal data of classifier.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_classifier_mac_update(struct sppwk_comp_info *comp_info);

/**
 * Update forwarder info.
 *
 * @param component Pointer to data of forwarder and merger.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_forward_update(struct sppwk_comp_info *component);

void init_classifier_info(int component_id);

void uninit_component_info(struct component_info *cmp_info);

int spp_classifier_mac_iterate_table(
		struct spp_iterate_classifier_table_params *params);

/**
 * classifier get component status.
 *
 * @param[in] lcore_id Lcore ID for classifier.
 * @param[in] id Unique component ID.
 * @param[in,out] params Pointer to detailed data of classifier status.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_classifier_get_component_status(unsigned int lcore_id, int id,
		struct spp_iterate_core_params *params);

/**
 * Merge/Forward get component status
 *
 * @param lcore_id Lcore ID for forwarder and merger.
 * @param id Unique component ID.
 * @param params Pointer detailed data of forwarder and merger status.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_forward_get_component_status(unsigned int lcore_id, int id,
		struct spp_iterate_core_params *params);

#endif  /* _SPPWK_TH_VF_DEPS_H_ */
