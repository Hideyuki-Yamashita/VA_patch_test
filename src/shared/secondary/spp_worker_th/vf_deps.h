/* SPDX-License-Identifier: BSD-3-Clause
 * Copyright(c) 2019 Nippon Telegraph and Telephone Corporation
 */

#ifndef _SPPWK_TH_VF_DEPS_H_
#define _SPPWK_TH_VF_DEPS_H_

#include <rte_malloc.h>
#include <rte_hash.h>
#include "cmd_utils.h"

/** Number of VLAN ID */
#define NOF_VLAN 4096

/* Classifier for MAC addresses. */
struct mac_classifier {
	struct rte_hash *cls_tbl;  /* Hash table for MAC classification. */
	int nof_cls_ports;  /* Num of ports classified validly. */
	int cls_ports[RTE_MAX_ETHPORTS];  /* Ports for classification. */
	int default_cls_idx;  /* Default index for classification. */
};

/* Attirbutes of port for classification. */
/* TODO(yasufum) confirm what is `iface_no_global`. */
struct cls_port_info {
	enum port_type iface_type;
	int iface_no;   /* Index of ports handled by classifier. */
	int iface_no_global;  /* ID for interface generated by spp_vf */
	uint16_t ethdev_port_id;  /* Ethdev port ID. */
	uint16_t nof_pkts;  /* Number of packets in pkts[]. */
	struct rte_mbuf *pkts[MAX_PKT_BURST];  /* packets to be classified. */
};

/* classifier component information */
struct cls_comp_info {
	char name[STR_LEN_NAME];  /* component name */
	int mac_addr_entry;  /* mac address entry flag */
	struct mac_classifier *mac_clfs[NOF_VLAN];  /* classifiers per VLAN. */
	int nof_tx_ports;  /* Number of TX ports info entries. */
	/* Classifier has one RX port and several TX ports. */
	struct cls_port_info rx_port_i;  /* RX port info classified. */
	struct cls_port_info tx_ports_i[RTE_MAX_ETHPORTS];  /* TX info. */
};

/* Release instance of mac classifier. */
static inline void
free_mac_classifier(struct mac_classifier *mac_clf)
{
	if (mac_clf == NULL)
		return;
	if (mac_clf->cls_tbl != NULL)
		rte_hash_free(mac_clf->cls_tbl);
	rte_free(mac_clf);
}

/**
 * classifier(mac address) update component info.
 *
 * @param comp_info Pointer to internal data of classifier.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_classifier_mac_update(struct sppwk_comp_info *comp_info);

/**
 * Update forwarder info.
 *
 * @param component Pointer to data of forwarder and merger.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_forward_update(struct sppwk_comp_info *component);

void init_classifier_info(int component_id);

void uninit_component_info(struct cls_comp_info *cmp_info);

int spp_classifier_mac_iterate_table(
		struct spp_iterate_classifier_table_params *params);

/**
 * classifier get component status.
 *
 * @param[in] lcore_id Lcore ID for classifier.
 * @param[in] id Unique component ID.
 * @param[in,out] params Pointer to detailed data of classifier status.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_classifier_get_component_status(unsigned int lcore_id, int id,
		struct spp_iterate_core_params *params);

/**
 * Merge/Forward get component status
 *
 * @param lcore_id Lcore ID for forwarder and merger.
 * @param id Unique component ID.
 * @param params Pointer detailed data of forwarder and merger status.
 * @retval SPP_RET_OK If succeeded.
 * @retval SPP_RET_NG If failed.
 */
int spp_forward_get_component_status(unsigned int lcore_id, int id,
		struct spp_iterate_core_params *params);

#endif  /* _SPPWK_TH_VF_DEPS_H_ */
